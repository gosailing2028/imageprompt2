"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@auth";
exports.ids = ["vendor-chunks/@auth"];
exports.modules = {

/***/ "(rsc)/../../node_modules/@auth/kysely-adapter/index.js":
/*!********************************************************!*\
  !*** ../../node_modules/@auth/kysely-adapter/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KyselyAdapter: () => (/* binding */ KyselyAdapter),\n/* harmony export */   KyselyAuth: () => (/* binding */ KyselyAuth),\n/* harmony export */   format: () => (/* binding */ format)\n/* harmony export */ });\n/* harmony import */ var kysely__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! kysely */ \"(rsc)/../../node_modules/kysely/dist/esm/dialect/sqlite/sqlite-adapter.js\");\n/* harmony import */ var kysely__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! kysely */ \"(rsc)/../../node_modules/kysely/dist/esm/kysely.js\");\n/**\n * <div style={{display: \"flex\", justifyContent: \"space-between\", alignItems: \"center\", padding: 16}}>\n *  <p style={{fontWeight: \"normal\"}}>Official <a href=\"https://kysely.dev/\">Kysely</a> adapter for Auth.js / NextAuth.js.</p>\n *  <a href=\"https://kysely.dev/\">\n *   <img style={{display: \"block\"}} src=\"/img/adapters/kysely.svg\" width=\"38\" />\n *  </a>\n * </div>\n *\n * ## Installation\n *\n * ```bash npm2yarn\n * npm install kysely @auth/kysely-adapter\n * ```\n *\n * @module @auth/kysely-adapter\n */\n\n// https://github.com/honeinc/is-iso-date/blob/master/index.js\nconst isoDateRE = /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/;\nfunction isDate(value) {\n    return value && isoDateRE.test(value) && !isNaN(Date.parse(value));\n}\nconst format = {\n    from(object) {\n        const newObject = {};\n        for (const key in object) {\n            const value = object[key];\n            if (isDate(value))\n                newObject[key] = new Date(value);\n            else\n                newObject[key] = value;\n        }\n        return newObject;\n    },\n    to(object) {\n        const newObject = {};\n        for (const [key, value] of Object.entries(object))\n            newObject[key] = value instanceof Date ? value.toISOString() : value;\n        return newObject;\n    },\n};\n/**\n *\n * ## Setup\n *\n * This adapter supports the same first party dialects that Kysely (as of v0.24.2) supports: PostgreSQL, MySQL, and SQLite. The examples below use PostgreSQL with the [pg](https://www.npmjs.com/package/pg) client.\n *\n *  ```bash npm2yarn\n * npm install pg\n * npm install --save-dev @types/pg\n * ```\n *\n * ```typescript title=\"pages/api/auth/[...nextauth].ts\"\n * import NextAuth from \"next-auth\"\n * import GoogleProvider from \"next-auth/providers/google\"\n * import { KyselyAdapter } from \"@auth/kysely-adapter\"\n * import { db } from \"../../../db\"\n *\n * export default NextAuth({\n *   adapter: KyselyAdapter(db),\n *   providers: [\n *     GoogleProvider({\n *       clientId: process.env.GOOGLE_CLIENT_ID,\n *       clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n *     }),\n *   ],\n * })\n * ```\n *\n * Kysely's constructor requires a database interface that contains an entry with an interface for each of your tables. You can define these types manually, or use `kysely-codegen` / `prisma-kysely` to automatically generate them. Check out the default [models](/reference/core/adapters#models) required by Auth.js.\n *\n * ```ts title=\"db.ts\"\n * import { PostgresDialect } from \"kysely\"\n * import { Pool } from \"pg\"\n *\n * // This adapter exports a wrapper of the original `Kysely` class called `KyselyAuth`,\n * // that can be used to provide additional type-safety.\n * // While using it isn't required, it is recommended as it will verify\n * // that the database interface has all the fields that Auth.js expects.\n * import { KyselyAuth } from \"@auth/kysely-adapter\"\n *\n * import type { GeneratedAlways } from \"kysely\"\n *\n * interface Database {\n *   User: {\n *     id: GeneratedAlways<string>\n *     name: string | null\n *     email: string\n *     emailVerified: Date | null\n *     image: string | null\n *   }\n *   Account: {\n *     id: GeneratedAlways<string>\n *     userId: string\n *     type: string\n *     provider: string\n *     providerAccountId: string\n *     refresh_token: string | null\n *     access_token: string | null\n *     expires_at: number | null\n *     token_type: string | null\n *     scope: string | null\n *     id_token: string | null\n *     session_state: string | null\n *   }\n *   Session: {\n *     id: GeneratedAlways<string>\n *     userId: string\n *     sessionToken: string\n *     expires: Date\n *   }\n *   VerificationToken: {\n *     identifier: string\n *     token: string\n *     expires: Date\n *   }\n * }\n *\n * export const db = new KyselyAuth<Database>({\n *   dialect: new PostgresDialect({\n *     pool: new Pool({\n *       host: process.env.DATABASE_HOST,\n *       database: process.env.DATABASE_NAME,\n *       user: process.env.DATABASE_USER,\n *       password: process.env.DATABASE_PASSWORD,\n *     }),\n *   }),\n * })\n```\n *\n *\n * :::note\n * An alternative to manually defining types is generating them from the database schema using [kysely-codegen](https://github.com/RobinBlomberg/kysely-codegen), or from Prisma schemas using [prisma-kysely](https://github.com/valtyr/prisma-kysely). When using generated types with `KyselyAuth`, import `Codegen` and pass it as the second generic arg:\n * ```ts\n * import type { Codegen } from \"@auth/kysely-adapter\"\n * new KyselyAuth<Database, Codegen>(...)\n * ```\n * :::\n * ### Schema\n * ```ts title=\"db/migrations/001_create_db.ts\"\n * import { Kysely, sql } from \"kysely\"\n *\n * export async function up(db: Kysely<any>): Promise<void> {\n *   await db.schema\n *     .createTable(\"User\")\n *     .addColumn(\"id\", \"uuid\", (col) =>\n *       col.primaryKey().defaultTo(sql`gen_random_uuid()`)\n *     )\n *     .addColumn(\"name\", \"text\")\n *     .addColumn(\"email\", \"text\", (col) => col.unique().notNull())\n *     .addColumn(\"emailVerified\", \"timestamptz\")\n *     .addColumn(\"image\", \"text\")\n *     .execute()\n *\n *   await db.schema\n *     .createTable(\"Account\")\n *     .addColumn(\"id\", \"uuid\", (col) =>\n *       col.primaryKey().defaultTo(sql`gen_random_uuid()`)\n *     )\n *     .addColumn(\"userId\", \"uuid\", (col) =>\n *       col.references(\"User.id\").onDelete(\"cascade\").notNull()\n *     )\n *     .addColumn(\"type\", \"text\", (col) => col.notNull())\n *     .addColumn(\"provider\", \"text\", (col) => col.notNull())\n *     .addColumn(\"providerAccountId\", \"text\", (col) => col.notNull())\n *     .addColumn(\"refresh_token\", \"text\")\n *     .addColumn(\"access_token\", \"text\")\n *     .addColumn(\"expires_at\", \"bigint\")\n *     .addColumn(\"token_type\", \"text\")\n *     .addColumn(\"scope\", \"text\")\n *     .addColumn(\"id_token\", \"text\")\n *     .addColumn(\"session_state\", \"text\")\n *     .execute()\n *\n *   await db.schema\n *     .createTable(\"Session\")\n *     .addColumn(\"id\", \"uuid\", (col) =>\n *       col.primaryKey().defaultTo(sql`gen_random_uuid()`)\n *     )\n *     .addColumn(\"userId\", \"uuid\", (col) =>\n *       col.references(\"User.id\").onDelete(\"cascade\").notNull()\n *     )\n *     .addColumn(\"sessionToken\", \"text\", (col) => col.notNull().unique())\n *     .addColumn(\"expires\", \"timestamptz\", (col) => col.notNull())\n *     .execute()\n *\n *   await db.schema\n *     .createTable(\"VerificationToken\")\n *     .addColumn(\"identifier\", \"text\", (col) => col.notNull())\n *     .addColumn(\"token\", \"text\", (col) => col.notNull().unique())\n *     .addColumn(\"expires\", \"timestamptz\", (col) => col.notNull())\n *     .execute()\n *\n *   await db.schema\n *     .createIndex(\"Account_userId_index\")\n *     .on(\"Account\")\n *     .column(\"userId\")\n *     .execute()\n *\n *   await db.schema\n *     .createIndex(\"Session_userId_index\")\n *     .on(\"Session\")\n *     .column(\"userId\")\n *     .execute()\n * }\n *\n * export async function down(db: Kysely<any>): Promise<void> {\n *   await db.schema.dropTable(\"Account\").ifExists().execute()\n *   await db.schema.dropTable(\"Session\").ifExists().execute()\n *   await db.schema.dropTable(\"User\").ifExists().execute()\n *   await db.schema.dropTable(\"VerificationToken\").ifExists().execute()\n * }\n * ```\n * > This schema is adapted for use in Kysely and is based upon our main [schema](/reference/core/adapters#models).\n *\n * For more information about creating and running migrations with Kysely, refer to the [Kysely migrations documentation](https://kysely.dev/docs/migrations).\n *\n * ### Naming conventions\n * If mixed snake_case and camelCase column names is an issue for you and/or your underlying database system, we recommend using Kysely's `CamelCasePlugin` ([see the documentation here](https://kysely-org.github.io/kysely-apidoc/classes/CamelCasePlugin.html)) feature to change the field names. This won't affect NextAuth.js, but will allow you to have consistent casing when using Kysely.\n */\nfunction KyselyAdapter(db) {\n    const { adapter } = db.getExecutor();\n    const { supportsReturning } = adapter;\n    const isSqlite = adapter instanceof kysely__WEBPACK_IMPORTED_MODULE_0__.SqliteAdapter;\n    /** If the database is SQLite, turn dates into an ISO string  */\n    const to = isSqlite ? format.to : (x) => x;\n    /** If the database is SQLite, turn ISO strings into dates */\n    const from = isSqlite ? format.from : (x) => x;\n    return {\n        async createUser(data) {\n            const user = { ...data, id: crypto.randomUUID() };\n            await db.insertInto(\"User\").values(to(user)).executeTakeFirstOrThrow();\n            return user;\n        },\n        async getUser(id) {\n            const result = await db\n                .selectFrom(\"User\")\n                .selectAll()\n                .where(\"id\", \"=\", id)\n                .executeTakeFirst();\n            if (!result)\n                return null;\n            return from(result);\n        },\n        async getUserByEmail(email) {\n            const result = await db\n                .selectFrom(\"User\")\n                .selectAll()\n                .where(\"email\", \"=\", email)\n                .executeTakeFirst();\n            if (!result)\n                return null;\n            return from(result);\n        },\n        async getUserByAccount({ providerAccountId, provider }) {\n            const result = await db\n                .selectFrom(\"User\")\n                .innerJoin(\"Account\", \"User.id\", \"Account.userId\")\n                .selectAll(\"User\")\n                .where(\"Account.providerAccountId\", \"=\", providerAccountId)\n                .where(\"Account.provider\", \"=\", provider)\n                .executeTakeFirst();\n            if (!result)\n                return null;\n            return from(result);\n        },\n        async updateUser({ id, ...user }) {\n            const userData = to(user);\n            const query = db.updateTable(\"User\").set(userData).where(\"id\", \"=\", id);\n            const result = supportsReturning\n                ? query.returningAll().executeTakeFirstOrThrow()\n                : query\n                    .executeTakeFirstOrThrow()\n                    .then(() => db\n                    .selectFrom(\"User\")\n                    .selectAll()\n                    .where(\"id\", \"=\", id)\n                    .executeTakeFirstOrThrow());\n            return from(await result);\n        },\n        async deleteUser(userId) {\n            await db\n                .deleteFrom(\"User\")\n                .where(\"User.id\", \"=\", userId)\n                .executeTakeFirst();\n        },\n        async linkAccount(account) {\n            await db\n                .insertInto(\"Account\")\n                .values(to(account))\n                .executeTakeFirstOrThrow();\n            return account;\n        },\n        async unlinkAccount({ providerAccountId, provider }) {\n            await db\n                .deleteFrom(\"Account\")\n                .where(\"Account.providerAccountId\", \"=\", providerAccountId)\n                .where(\"Account.provider\", \"=\", provider)\n                .executeTakeFirstOrThrow();\n        },\n        async createSession(session) {\n            await db.insertInto(\"Session\").values(to(session)).execute();\n            return session;\n        },\n        async getSessionAndUser(sessionToken) {\n            const result = await db\n                .selectFrom(\"Session\")\n                .innerJoin(\"User\", \"User.id\", \"Session.userId\")\n                .selectAll(\"User\")\n                .select([\"Session.expires\", \"Session.userId\"])\n                .where(\"Session.sessionToken\", \"=\", sessionToken)\n                .executeTakeFirst();\n            if (!result)\n                return null;\n            const { userId, expires, ...user } = result;\n            const session = { sessionToken, userId, expires };\n            return { user: from(user), session: from(session) };\n        },\n        async updateSession(session) {\n            const sessionData = to(session);\n            const query = db\n                .updateTable(\"Session\")\n                .set(sessionData)\n                .where(\"Session.sessionToken\", \"=\", session.sessionToken);\n            const result = supportsReturning\n                ? await query.returningAll().executeTakeFirstOrThrow()\n                : await query.executeTakeFirstOrThrow().then(async () => {\n                    return await db\n                        .selectFrom(\"Session\")\n                        .selectAll()\n                        .where(\"Session.sessionToken\", \"=\", sessionData.sessionToken)\n                        .executeTakeFirstOrThrow();\n                });\n            return from(result);\n        },\n        async deleteSession(sessionToken) {\n            await db\n                .deleteFrom(\"Session\")\n                .where(\"Session.sessionToken\", \"=\", sessionToken)\n                .executeTakeFirstOrThrow();\n        },\n        async createVerificationToken(data) {\n            await db.insertInto(\"VerificationToken\").values(to(data)).execute();\n            return data;\n        },\n        async useVerificationToken({ identifier, token }) {\n            const query = db\n                .deleteFrom(\"VerificationToken\")\n                .where(\"VerificationToken.token\", \"=\", token)\n                .where(\"VerificationToken.identifier\", \"=\", identifier);\n            const result = supportsReturning\n                ? await query.returningAll().executeTakeFirst()\n                : await db\n                    .selectFrom(\"VerificationToken\")\n                    .selectAll()\n                    .where(\"token\", \"=\", token)\n                    .executeTakeFirst()\n                    .then(async (res) => {\n                    await query.executeTakeFirst();\n                    return res;\n                });\n            if (!result)\n                return null;\n            return from(result);\n        },\n    };\n}\n/**\n * Wrapper over the original `Kysely` class in order to validate the passed in\n * database interface. A regular Kysely instance may also be used, but wrapping\n * it ensures the database interface implements the fields that Auth.js\n * requires. When used with `kysely-codegen`, the `Codegen` type can be passed as\n * the second generic argument. The generated types will be used, and\n * `KyselyAuth` will only verify that the correct fields exist.\n */\nclass KyselyAuth extends kysely__WEBPACK_IMPORTED_MODULE_1__.Kysely {\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhdXRoL2t5c2VseS1hZGFwdGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQSxnQkFBZ0IscUZBQXFGO0FBQ3JHLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytDO0FBQy9DO0FBQ0EsdUJBQXVCLEVBQUUseUVBQXlFLEVBQUUsb0VBQW9FLEVBQUU7QUFDMUs7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxVQUFVO0FBQ3RCLFlBQVksb0JBQW9CO0FBQ2hDLHdDQUF3QyxpREFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlDQUFpQyw2QkFBNkI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLDhCQUE4QjtBQUM5QixxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5QiwwQ0FBTTtBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzYWFzZmx5L25leHRqcy8uLi8uLi9ub2RlX21vZHVsZXMvQGF1dGgva3lzZWx5LWFkYXB0ZXIvaW5kZXguanM/OTU4MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIDxkaXYgc3R5bGU9e3tkaXNwbGF5OiBcImZsZXhcIiwganVzdGlmeUNvbnRlbnQ6IFwic3BhY2UtYmV0d2VlblwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLCBwYWRkaW5nOiAxNn19PlxuICogIDxwIHN0eWxlPXt7Zm9udFdlaWdodDogXCJub3JtYWxcIn19Pk9mZmljaWFsIDxhIGhyZWY9XCJodHRwczovL2t5c2VseS5kZXYvXCI+S3lzZWx5PC9hPiBhZGFwdGVyIGZvciBBdXRoLmpzIC8gTmV4dEF1dGguanMuPC9wPlxuICogIDxhIGhyZWY9XCJodHRwczovL2t5c2VseS5kZXYvXCI+XG4gKiAgIDxpbWcgc3R5bGU9e3tkaXNwbGF5OiBcImJsb2NrXCJ9fSBzcmM9XCIvaW1nL2FkYXB0ZXJzL2t5c2VseS5zdmdcIiB3aWR0aD1cIjM4XCIgLz5cbiAqICA8L2E+XG4gKiA8L2Rpdj5cbiAqXG4gKiAjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBgYGBiYXNoIG5wbTJ5YXJuXG4gKiBucG0gaW5zdGFsbCBreXNlbHkgQGF1dGgva3lzZWx5LWFkYXB0ZXJcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgQGF1dGgva3lzZWx5LWFkYXB0ZXJcbiAqL1xuaW1wb3J0IHsgS3lzZWx5LCBTcWxpdGVBZGFwdGVyIH0gZnJvbSBcImt5c2VseVwiO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2hvbmVpbmMvaXMtaXNvLWRhdGUvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmNvbnN0IGlzb0RhdGVSRSA9IC8oXFxkezR9LVswMV1cXGQtWzAtM11cXGRUWzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGRcXC5cXGQrKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSl8KFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSl8KFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSkvO1xuZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIGlzb0RhdGVSRS50ZXN0KHZhbHVlKSAmJiAhaXNOYU4oRGF0ZS5wYXJzZSh2YWx1ZSkpO1xufVxuZXhwb3J0IGNvbnN0IGZvcm1hdCA9IHtcbiAgICBmcm9tKG9iamVjdCkge1xuICAgICAgICBjb25zdCBuZXdPYmplY3QgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgaWYgKGlzRGF0ZSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgbmV3T2JqZWN0W2tleV0gPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbmV3T2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T2JqZWN0O1xuICAgIH0sXG4gICAgdG8ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5ld09iamVjdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmplY3QpKVxuICAgICAgICAgICAgbmV3T2JqZWN0W2tleV0gPSB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyB2YWx1ZS50b0lTT1N0cmluZygpIDogdmFsdWU7XG4gICAgICAgIHJldHVybiBuZXdPYmplY3Q7XG4gICAgfSxcbn07XG4vKipcbiAqXG4gKiAjIyBTZXR1cFxuICpcbiAqIFRoaXMgYWRhcHRlciBzdXBwb3J0cyB0aGUgc2FtZSBmaXJzdCBwYXJ0eSBkaWFsZWN0cyB0aGF0IEt5c2VseSAoYXMgb2YgdjAuMjQuMikgc3VwcG9ydHM6IFBvc3RncmVTUUwsIE15U1FMLCBhbmQgU1FMaXRlLiBUaGUgZXhhbXBsZXMgYmVsb3cgdXNlIFBvc3RncmVTUUwgd2l0aCB0aGUgW3BnXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9wZykgY2xpZW50LlxuICpcbiAqICBgYGBiYXNoIG5wbTJ5YXJuXG4gKiBucG0gaW5zdGFsbCBwZ1xuICogbnBtIGluc3RhbGwgLS1zYXZlLWRldiBAdHlwZXMvcGdcbiAqIGBgYFxuICpcbiAqIGBgYHR5cGVzY3JpcHQgdGl0bGU9XCJwYWdlcy9hcGkvYXV0aC9bLi4ubmV4dGF1dGhdLnRzXCJcbiAqIGltcG9ydCBOZXh0QXV0aCBmcm9tIFwibmV4dC1hdXRoXCJcbiAqIGltcG9ydCBHb29nbGVQcm92aWRlciBmcm9tIFwibmV4dC1hdXRoL3Byb3ZpZGVycy9nb29nbGVcIlxuICogaW1wb3J0IHsgS3lzZWx5QWRhcHRlciB9IGZyb20gXCJAYXV0aC9reXNlbHktYWRhcHRlclwiXG4gKiBpbXBvcnQgeyBkYiB9IGZyb20gXCIuLi8uLi8uLi9kYlwiXG4gKlxuICogZXhwb3J0IGRlZmF1bHQgTmV4dEF1dGgoe1xuICogICBhZGFwdGVyOiBLeXNlbHlBZGFwdGVyKGRiKSxcbiAqICAgcHJvdmlkZXJzOiBbXG4gKiAgICAgR29vZ2xlUHJvdmlkZXIoe1xuICogICAgICAgY2xpZW50SWQ6IHByb2Nlc3MuZW52LkdPT0dMRV9DTElFTlRfSUQsXG4gKiAgICAgICBjbGllbnRTZWNyZXQ6IHByb2Nlc3MuZW52LkdPT0dMRV9DTElFTlRfU0VDUkVULFxuICogICAgIH0pLFxuICogICBdLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEt5c2VseSdzIGNvbnN0cnVjdG9yIHJlcXVpcmVzIGEgZGF0YWJhc2UgaW50ZXJmYWNlIHRoYXQgY29udGFpbnMgYW4gZW50cnkgd2l0aCBhbiBpbnRlcmZhY2UgZm9yIGVhY2ggb2YgeW91ciB0YWJsZXMuIFlvdSBjYW4gZGVmaW5lIHRoZXNlIHR5cGVzIG1hbnVhbGx5LCBvciB1c2UgYGt5c2VseS1jb2RlZ2VuYCAvIGBwcmlzbWEta3lzZWx5YCB0byBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIHRoZW0uIENoZWNrIG91dCB0aGUgZGVmYXVsdCBbbW9kZWxzXSgvcmVmZXJlbmNlL2NvcmUvYWRhcHRlcnMjbW9kZWxzKSByZXF1aXJlZCBieSBBdXRoLmpzLlxuICpcbiAqIGBgYHRzIHRpdGxlPVwiZGIudHNcIlxuICogaW1wb3J0IHsgUG9zdGdyZXNEaWFsZWN0IH0gZnJvbSBcImt5c2VseVwiXG4gKiBpbXBvcnQgeyBQb29sIH0gZnJvbSBcInBnXCJcbiAqXG4gKiAvLyBUaGlzIGFkYXB0ZXIgZXhwb3J0cyBhIHdyYXBwZXIgb2YgdGhlIG9yaWdpbmFsIGBLeXNlbHlgIGNsYXNzIGNhbGxlZCBgS3lzZWx5QXV0aGAsXG4gKiAvLyB0aGF0IGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgYWRkaXRpb25hbCB0eXBlLXNhZmV0eS5cbiAqIC8vIFdoaWxlIHVzaW5nIGl0IGlzbid0IHJlcXVpcmVkLCBpdCBpcyByZWNvbW1lbmRlZCBhcyBpdCB3aWxsIHZlcmlmeVxuICogLy8gdGhhdCB0aGUgZGF0YWJhc2UgaW50ZXJmYWNlIGhhcyBhbGwgdGhlIGZpZWxkcyB0aGF0IEF1dGguanMgZXhwZWN0cy5cbiAqIGltcG9ydCB7IEt5c2VseUF1dGggfSBmcm9tIFwiQGF1dGgva3lzZWx5LWFkYXB0ZXJcIlxuICpcbiAqIGltcG9ydCB0eXBlIHsgR2VuZXJhdGVkQWx3YXlzIH0gZnJvbSBcImt5c2VseVwiXG4gKlxuICogaW50ZXJmYWNlIERhdGFiYXNlIHtcbiAqICAgVXNlcjoge1xuICogICAgIGlkOiBHZW5lcmF0ZWRBbHdheXM8c3RyaW5nPlxuICogICAgIG5hbWU6IHN0cmluZyB8IG51bGxcbiAqICAgICBlbWFpbDogc3RyaW5nXG4gKiAgICAgZW1haWxWZXJpZmllZDogRGF0ZSB8IG51bGxcbiAqICAgICBpbWFnZTogc3RyaW5nIHwgbnVsbFxuICogICB9XG4gKiAgIEFjY291bnQ6IHtcbiAqICAgICBpZDogR2VuZXJhdGVkQWx3YXlzPHN0cmluZz5cbiAqICAgICB1c2VySWQ6IHN0cmluZ1xuICogICAgIHR5cGU6IHN0cmluZ1xuICogICAgIHByb3ZpZGVyOiBzdHJpbmdcbiAqICAgICBwcm92aWRlckFjY291bnRJZDogc3RyaW5nXG4gKiAgICAgcmVmcmVzaF90b2tlbjogc3RyaW5nIHwgbnVsbFxuICogICAgIGFjY2Vzc190b2tlbjogc3RyaW5nIHwgbnVsbFxuICogICAgIGV4cGlyZXNfYXQ6IG51bWJlciB8IG51bGxcbiAqICAgICB0b2tlbl90eXBlOiBzdHJpbmcgfCBudWxsXG4gKiAgICAgc2NvcGU6IHN0cmluZyB8IG51bGxcbiAqICAgICBpZF90b2tlbjogc3RyaW5nIHwgbnVsbFxuICogICAgIHNlc3Npb25fc3RhdGU6IHN0cmluZyB8IG51bGxcbiAqICAgfVxuICogICBTZXNzaW9uOiB7XG4gKiAgICAgaWQ6IEdlbmVyYXRlZEFsd2F5czxzdHJpbmc+XG4gKiAgICAgdXNlcklkOiBzdHJpbmdcbiAqICAgICBzZXNzaW9uVG9rZW46IHN0cmluZ1xuICogICAgIGV4cGlyZXM6IERhdGVcbiAqICAgfVxuICogICBWZXJpZmljYXRpb25Ub2tlbjoge1xuICogICAgIGlkZW50aWZpZXI6IHN0cmluZ1xuICogICAgIHRva2VuOiBzdHJpbmdcbiAqICAgICBleHBpcmVzOiBEYXRlXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBleHBvcnQgY29uc3QgZGIgPSBuZXcgS3lzZWx5QXV0aDxEYXRhYmFzZT4oe1xuICogICBkaWFsZWN0OiBuZXcgUG9zdGdyZXNEaWFsZWN0KHtcbiAqICAgICBwb29sOiBuZXcgUG9vbCh7XG4gKiAgICAgICBob3N0OiBwcm9jZXNzLmVudi5EQVRBQkFTRV9IT1NULFxuICogICAgICAgZGF0YWJhc2U6IHByb2Nlc3MuZW52LkRBVEFCQVNFX05BTUUsXG4gKiAgICAgICB1c2VyOiBwcm9jZXNzLmVudi5EQVRBQkFTRV9VU0VSLFxuICogICAgICAgcGFzc3dvcmQ6IHByb2Nlc3MuZW52LkRBVEFCQVNFX1BBU1NXT1JELFxuICogICAgIH0pLFxuICogICB9KSxcbiAqIH0pXG5gYGBcbiAqXG4gKlxuICogOjo6bm90ZVxuICogQW4gYWx0ZXJuYXRpdmUgdG8gbWFudWFsbHkgZGVmaW5pbmcgdHlwZXMgaXMgZ2VuZXJhdGluZyB0aGVtIGZyb20gdGhlIGRhdGFiYXNlIHNjaGVtYSB1c2luZyBba3lzZWx5LWNvZGVnZW5dKGh0dHBzOi8vZ2l0aHViLmNvbS9Sb2JpbkJsb21iZXJnL2t5c2VseS1jb2RlZ2VuKSwgb3IgZnJvbSBQcmlzbWEgc2NoZW1hcyB1c2luZyBbcHJpc21hLWt5c2VseV0oaHR0cHM6Ly9naXRodWIuY29tL3ZhbHR5ci9wcmlzbWEta3lzZWx5KS4gV2hlbiB1c2luZyBnZW5lcmF0ZWQgdHlwZXMgd2l0aCBgS3lzZWx5QXV0aGAsIGltcG9ydCBgQ29kZWdlbmAgYW5kIHBhc3MgaXQgYXMgdGhlIHNlY29uZCBnZW5lcmljIGFyZzpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgdHlwZSB7IENvZGVnZW4gfSBmcm9tIFwiQGF1dGgva3lzZWx5LWFkYXB0ZXJcIlxuICogbmV3IEt5c2VseUF1dGg8RGF0YWJhc2UsIENvZGVnZW4+KC4uLilcbiAqIGBgYFxuICogOjo6XG4gKiAjIyMgU2NoZW1hXG4gKiBgYGB0cyB0aXRsZT1cImRiL21pZ3JhdGlvbnMvMDAxX2NyZWF0ZV9kYi50c1wiXG4gKiBpbXBvcnQgeyBLeXNlbHksIHNxbCB9IGZyb20gXCJreXNlbHlcIlxuICpcbiAqIGV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cChkYjogS3lzZWx5PGFueT4pOiBQcm9taXNlPHZvaWQ+IHtcbiAqICAgYXdhaXQgZGIuc2NoZW1hXG4gKiAgICAgLmNyZWF0ZVRhYmxlKFwiVXNlclwiKVxuICogICAgIC5hZGRDb2x1bW4oXCJpZFwiLCBcInV1aWRcIiwgKGNvbCkgPT5cbiAqICAgICAgIGNvbC5wcmltYXJ5S2V5KCkuZGVmYXVsdFRvKHNxbGBnZW5fcmFuZG9tX3V1aWQoKWApXG4gKiAgICAgKVxuICogICAgIC5hZGRDb2x1bW4oXCJuYW1lXCIsIFwidGV4dFwiKVxuICogICAgIC5hZGRDb2x1bW4oXCJlbWFpbFwiLCBcInRleHRcIiwgKGNvbCkgPT4gY29sLnVuaXF1ZSgpLm5vdE51bGwoKSlcbiAqICAgICAuYWRkQ29sdW1uKFwiZW1haWxWZXJpZmllZFwiLCBcInRpbWVzdGFtcHR6XCIpXG4gKiAgICAgLmFkZENvbHVtbihcImltYWdlXCIsIFwidGV4dFwiKVxuICogICAgIC5leGVjdXRlKClcbiAqXG4gKiAgIGF3YWl0IGRiLnNjaGVtYVxuICogICAgIC5jcmVhdGVUYWJsZShcIkFjY291bnRcIilcbiAqICAgICAuYWRkQ29sdW1uKFwiaWRcIiwgXCJ1dWlkXCIsIChjb2wpID0+XG4gKiAgICAgICBjb2wucHJpbWFyeUtleSgpLmRlZmF1bHRUbyhzcWxgZ2VuX3JhbmRvbV91dWlkKClgKVxuICogICAgIClcbiAqICAgICAuYWRkQ29sdW1uKFwidXNlcklkXCIsIFwidXVpZFwiLCAoY29sKSA9PlxuICogICAgICAgY29sLnJlZmVyZW5jZXMoXCJVc2VyLmlkXCIpLm9uRGVsZXRlKFwiY2FzY2FkZVwiKS5ub3ROdWxsKClcbiAqICAgICApXG4gKiAgICAgLmFkZENvbHVtbihcInR5cGVcIiwgXCJ0ZXh0XCIsIChjb2wpID0+IGNvbC5ub3ROdWxsKCkpXG4gKiAgICAgLmFkZENvbHVtbihcInByb3ZpZGVyXCIsIFwidGV4dFwiLCAoY29sKSA9PiBjb2wubm90TnVsbCgpKVxuICogICAgIC5hZGRDb2x1bW4oXCJwcm92aWRlckFjY291bnRJZFwiLCBcInRleHRcIiwgKGNvbCkgPT4gY29sLm5vdE51bGwoKSlcbiAqICAgICAuYWRkQ29sdW1uKFwicmVmcmVzaF90b2tlblwiLCBcInRleHRcIilcbiAqICAgICAuYWRkQ29sdW1uKFwiYWNjZXNzX3Rva2VuXCIsIFwidGV4dFwiKVxuICogICAgIC5hZGRDb2x1bW4oXCJleHBpcmVzX2F0XCIsIFwiYmlnaW50XCIpXG4gKiAgICAgLmFkZENvbHVtbihcInRva2VuX3R5cGVcIiwgXCJ0ZXh0XCIpXG4gKiAgICAgLmFkZENvbHVtbihcInNjb3BlXCIsIFwidGV4dFwiKVxuICogICAgIC5hZGRDb2x1bW4oXCJpZF90b2tlblwiLCBcInRleHRcIilcbiAqICAgICAuYWRkQ29sdW1uKFwic2Vzc2lvbl9zdGF0ZVwiLCBcInRleHRcIilcbiAqICAgICAuZXhlY3V0ZSgpXG4gKlxuICogICBhd2FpdCBkYi5zY2hlbWFcbiAqICAgICAuY3JlYXRlVGFibGUoXCJTZXNzaW9uXCIpXG4gKiAgICAgLmFkZENvbHVtbihcImlkXCIsIFwidXVpZFwiLCAoY29sKSA9PlxuICogICAgICAgY29sLnByaW1hcnlLZXkoKS5kZWZhdWx0VG8oc3FsYGdlbl9yYW5kb21fdXVpZCgpYClcbiAqICAgICApXG4gKiAgICAgLmFkZENvbHVtbihcInVzZXJJZFwiLCBcInV1aWRcIiwgKGNvbCkgPT5cbiAqICAgICAgIGNvbC5yZWZlcmVuY2VzKFwiVXNlci5pZFwiKS5vbkRlbGV0ZShcImNhc2NhZGVcIikubm90TnVsbCgpXG4gKiAgICAgKVxuICogICAgIC5hZGRDb2x1bW4oXCJzZXNzaW9uVG9rZW5cIiwgXCJ0ZXh0XCIsIChjb2wpID0+IGNvbC5ub3ROdWxsKCkudW5pcXVlKCkpXG4gKiAgICAgLmFkZENvbHVtbihcImV4cGlyZXNcIiwgXCJ0aW1lc3RhbXB0elwiLCAoY29sKSA9PiBjb2wubm90TnVsbCgpKVxuICogICAgIC5leGVjdXRlKClcbiAqXG4gKiAgIGF3YWl0IGRiLnNjaGVtYVxuICogICAgIC5jcmVhdGVUYWJsZShcIlZlcmlmaWNhdGlvblRva2VuXCIpXG4gKiAgICAgLmFkZENvbHVtbihcImlkZW50aWZpZXJcIiwgXCJ0ZXh0XCIsIChjb2wpID0+IGNvbC5ub3ROdWxsKCkpXG4gKiAgICAgLmFkZENvbHVtbihcInRva2VuXCIsIFwidGV4dFwiLCAoY29sKSA9PiBjb2wubm90TnVsbCgpLnVuaXF1ZSgpKVxuICogICAgIC5hZGRDb2x1bW4oXCJleHBpcmVzXCIsIFwidGltZXN0YW1wdHpcIiwgKGNvbCkgPT4gY29sLm5vdE51bGwoKSlcbiAqICAgICAuZXhlY3V0ZSgpXG4gKlxuICogICBhd2FpdCBkYi5zY2hlbWFcbiAqICAgICAuY3JlYXRlSW5kZXgoXCJBY2NvdW50X3VzZXJJZF9pbmRleFwiKVxuICogICAgIC5vbihcIkFjY291bnRcIilcbiAqICAgICAuY29sdW1uKFwidXNlcklkXCIpXG4gKiAgICAgLmV4ZWN1dGUoKVxuICpcbiAqICAgYXdhaXQgZGIuc2NoZW1hXG4gKiAgICAgLmNyZWF0ZUluZGV4KFwiU2Vzc2lvbl91c2VySWRfaW5kZXhcIilcbiAqICAgICAub24oXCJTZXNzaW9uXCIpXG4gKiAgICAgLmNvbHVtbihcInVzZXJJZFwiKVxuICogICAgIC5leGVjdXRlKClcbiAqIH1cbiAqXG4gKiBleHBvcnQgYXN5bmMgZnVuY3Rpb24gZG93bihkYjogS3lzZWx5PGFueT4pOiBQcm9taXNlPHZvaWQ+IHtcbiAqICAgYXdhaXQgZGIuc2NoZW1hLmRyb3BUYWJsZShcIkFjY291bnRcIikuaWZFeGlzdHMoKS5leGVjdXRlKClcbiAqICAgYXdhaXQgZGIuc2NoZW1hLmRyb3BUYWJsZShcIlNlc3Npb25cIikuaWZFeGlzdHMoKS5leGVjdXRlKClcbiAqICAgYXdhaXQgZGIuc2NoZW1hLmRyb3BUYWJsZShcIlVzZXJcIikuaWZFeGlzdHMoKS5leGVjdXRlKClcbiAqICAgYXdhaXQgZGIuc2NoZW1hLmRyb3BUYWJsZShcIlZlcmlmaWNhdGlvblRva2VuXCIpLmlmRXhpc3RzKCkuZXhlY3V0ZSgpXG4gKiB9XG4gKiBgYGBcbiAqID4gVGhpcyBzY2hlbWEgaXMgYWRhcHRlZCBmb3IgdXNlIGluIEt5c2VseSBhbmQgaXMgYmFzZWQgdXBvbiBvdXIgbWFpbiBbc2NoZW1hXSgvcmVmZXJlbmNlL2NvcmUvYWRhcHRlcnMjbW9kZWxzKS5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBjcmVhdGluZyBhbmQgcnVubmluZyBtaWdyYXRpb25zIHdpdGggS3lzZWx5LCByZWZlciB0byB0aGUgW0t5c2VseSBtaWdyYXRpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8va3lzZWx5LmRldi9kb2NzL21pZ3JhdGlvbnMpLlxuICpcbiAqICMjIyBOYW1pbmcgY29udmVudGlvbnNcbiAqIElmIG1peGVkIHNuYWtlX2Nhc2UgYW5kIGNhbWVsQ2FzZSBjb2x1bW4gbmFtZXMgaXMgYW4gaXNzdWUgZm9yIHlvdSBhbmQvb3IgeW91ciB1bmRlcmx5aW5nIGRhdGFiYXNlIHN5c3RlbSwgd2UgcmVjb21tZW5kIHVzaW5nIEt5c2VseSdzIGBDYW1lbENhc2VQbHVnaW5gIChbc2VlIHRoZSBkb2N1bWVudGF0aW9uIGhlcmVdKGh0dHBzOi8va3lzZWx5LW9yZy5naXRodWIuaW8va3lzZWx5LWFwaWRvYy9jbGFzc2VzL0NhbWVsQ2FzZVBsdWdpbi5odG1sKSkgZmVhdHVyZSB0byBjaGFuZ2UgdGhlIGZpZWxkIG5hbWVzLiBUaGlzIHdvbid0IGFmZmVjdCBOZXh0QXV0aC5qcywgYnV0IHdpbGwgYWxsb3cgeW91IHRvIGhhdmUgY29uc2lzdGVudCBjYXNpbmcgd2hlbiB1c2luZyBLeXNlbHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBLeXNlbHlBZGFwdGVyKGRiKSB7XG4gICAgY29uc3QgeyBhZGFwdGVyIH0gPSBkYi5nZXRFeGVjdXRvcigpO1xuICAgIGNvbnN0IHsgc3VwcG9ydHNSZXR1cm5pbmcgfSA9IGFkYXB0ZXI7XG4gICAgY29uc3QgaXNTcWxpdGUgPSBhZGFwdGVyIGluc3RhbmNlb2YgU3FsaXRlQWRhcHRlcjtcbiAgICAvKiogSWYgdGhlIGRhdGFiYXNlIGlzIFNRTGl0ZSwgdHVybiBkYXRlcyBpbnRvIGFuIElTTyBzdHJpbmcgICovXG4gICAgY29uc3QgdG8gPSBpc1NxbGl0ZSA/IGZvcm1hdC50byA6ICh4KSA9PiB4O1xuICAgIC8qKiBJZiB0aGUgZGF0YWJhc2UgaXMgU1FMaXRlLCB0dXJuIElTTyBzdHJpbmdzIGludG8gZGF0ZXMgKi9cbiAgICBjb25zdCBmcm9tID0gaXNTcWxpdGUgPyBmb3JtYXQuZnJvbSA6ICh4KSA9PiB4O1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jIGNyZWF0ZVVzZXIoZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IHsgLi4uZGF0YSwgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCkgfTtcbiAgICAgICAgICAgIGF3YWl0IGRiLmluc2VydEludG8oXCJVc2VyXCIpLnZhbHVlcyh0byh1c2VyKSkuZXhlY3V0ZVRha2VGaXJzdE9yVGhyb3coKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VyO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRVc2VyKGlkKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkYlxuICAgICAgICAgICAgICAgIC5zZWxlY3RGcm9tKFwiVXNlclwiKVxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoKVxuICAgICAgICAgICAgICAgIC53aGVyZShcImlkXCIsIFwiPVwiLCBpZClcbiAgICAgICAgICAgICAgICAuZXhlY3V0ZVRha2VGaXJzdCgpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZnJvbShyZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRVc2VyQnlFbWFpbChlbWFpbCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGJcbiAgICAgICAgICAgICAgICAuc2VsZWN0RnJvbShcIlVzZXJcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKClcbiAgICAgICAgICAgICAgICAud2hlcmUoXCJlbWFpbFwiLCBcIj1cIiwgZW1haWwpXG4gICAgICAgICAgICAgICAgLmV4ZWN1dGVUYWtlRmlyc3QoKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20ocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0VXNlckJ5QWNjb3VudCh7IHByb3ZpZGVyQWNjb3VudElkLCBwcm92aWRlciB9KSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkYlxuICAgICAgICAgICAgICAgIC5zZWxlY3RGcm9tKFwiVXNlclwiKVxuICAgICAgICAgICAgICAgIC5pbm5lckpvaW4oXCJBY2NvdW50XCIsIFwiVXNlci5pZFwiLCBcIkFjY291bnQudXNlcklkXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIlVzZXJcIilcbiAgICAgICAgICAgICAgICAud2hlcmUoXCJBY2NvdW50LnByb3ZpZGVyQWNjb3VudElkXCIsIFwiPVwiLCBwcm92aWRlckFjY291bnRJZClcbiAgICAgICAgICAgICAgICAud2hlcmUoXCJBY2NvdW50LnByb3ZpZGVyXCIsIFwiPVwiLCBwcm92aWRlcilcbiAgICAgICAgICAgICAgICAuZXhlY3V0ZVRha2VGaXJzdCgpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZnJvbShyZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyB1cGRhdGVVc2VyKHsgaWQsIC4uLnVzZXIgfSkge1xuICAgICAgICAgICAgY29uc3QgdXNlckRhdGEgPSB0byh1c2VyKTtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gZGIudXBkYXRlVGFibGUoXCJVc2VyXCIpLnNldCh1c2VyRGF0YSkud2hlcmUoXCJpZFwiLCBcIj1cIiwgaWQpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwcG9ydHNSZXR1cm5pbmdcbiAgICAgICAgICAgICAgICA/IHF1ZXJ5LnJldHVybmluZ0FsbCgpLmV4ZWN1dGVUYWtlRmlyc3RPclRocm93KClcbiAgICAgICAgICAgICAgICA6IHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIC5leGVjdXRlVGFrZUZpcnN0T3JUaHJvdygpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IGRiXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RGcm9tKFwiVXNlclwiKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKClcbiAgICAgICAgICAgICAgICAgICAgLndoZXJlKFwiaWRcIiwgXCI9XCIsIGlkKVxuICAgICAgICAgICAgICAgICAgICAuZXhlY3V0ZVRha2VGaXJzdE9yVGhyb3coKSk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbShhd2FpdCByZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBkZWxldGVVc2VyKHVzZXJJZCkge1xuICAgICAgICAgICAgYXdhaXQgZGJcbiAgICAgICAgICAgICAgICAuZGVsZXRlRnJvbShcIlVzZXJcIilcbiAgICAgICAgICAgICAgICAud2hlcmUoXCJVc2VyLmlkXCIsIFwiPVwiLCB1c2VySWQpXG4gICAgICAgICAgICAgICAgLmV4ZWN1dGVUYWtlRmlyc3QoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgbGlua0FjY291bnQoYWNjb3VudCkge1xuICAgICAgICAgICAgYXdhaXQgZGJcbiAgICAgICAgICAgICAgICAuaW5zZXJ0SW50byhcIkFjY291bnRcIilcbiAgICAgICAgICAgICAgICAudmFsdWVzKHRvKGFjY291bnQpKVxuICAgICAgICAgICAgICAgIC5leGVjdXRlVGFrZUZpcnN0T3JUaHJvdygpO1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHVubGlua0FjY291bnQoeyBwcm92aWRlckFjY291bnRJZCwgcHJvdmlkZXIgfSkge1xuICAgICAgICAgICAgYXdhaXQgZGJcbiAgICAgICAgICAgICAgICAuZGVsZXRlRnJvbShcIkFjY291bnRcIilcbiAgICAgICAgICAgICAgICAud2hlcmUoXCJBY2NvdW50LnByb3ZpZGVyQWNjb3VudElkXCIsIFwiPVwiLCBwcm92aWRlckFjY291bnRJZClcbiAgICAgICAgICAgICAgICAud2hlcmUoXCJBY2NvdW50LnByb3ZpZGVyXCIsIFwiPVwiLCBwcm92aWRlcilcbiAgICAgICAgICAgICAgICAuZXhlY3V0ZVRha2VGaXJzdE9yVGhyb3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgY3JlYXRlU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5pbnNlcnRJbnRvKFwiU2Vzc2lvblwiKS52YWx1ZXModG8oc2Vzc2lvbikpLmV4ZWN1dGUoKTtcbiAgICAgICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRTZXNzaW9uQW5kVXNlcihzZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRiXG4gICAgICAgICAgICAgICAgLnNlbGVjdEZyb20oXCJTZXNzaW9uXCIpXG4gICAgICAgICAgICAgICAgLmlubmVySm9pbihcIlVzZXJcIiwgXCJVc2VyLmlkXCIsIFwiU2Vzc2lvbi51c2VySWRcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiVXNlclwiKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoW1wiU2Vzc2lvbi5leHBpcmVzXCIsIFwiU2Vzc2lvbi51c2VySWRcIl0pXG4gICAgICAgICAgICAgICAgLndoZXJlKFwiU2Vzc2lvbi5zZXNzaW9uVG9rZW5cIiwgXCI9XCIsIHNlc3Npb25Ub2tlbilcbiAgICAgICAgICAgICAgICAuZXhlY3V0ZVRha2VGaXJzdCgpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCB7IHVzZXJJZCwgZXhwaXJlcywgLi4udXNlciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHsgc2Vzc2lvblRva2VuLCB1c2VySWQsIGV4cGlyZXMgfTtcbiAgICAgICAgICAgIHJldHVybiB7IHVzZXI6IGZyb20odXNlciksIHNlc3Npb246IGZyb20oc2Vzc2lvbikgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgdXBkYXRlU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uRGF0YSA9IHRvKHNlc3Npb24pO1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBkYlxuICAgICAgICAgICAgICAgIC51cGRhdGVUYWJsZShcIlNlc3Npb25cIilcbiAgICAgICAgICAgICAgICAuc2V0KHNlc3Npb25EYXRhKVxuICAgICAgICAgICAgICAgIC53aGVyZShcIlNlc3Npb24uc2Vzc2lvblRva2VuXCIsIFwiPVwiLCBzZXNzaW9uLnNlc3Npb25Ub2tlbik7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBwb3J0c1JldHVybmluZ1xuICAgICAgICAgICAgICAgID8gYXdhaXQgcXVlcnkucmV0dXJuaW5nQWxsKCkuZXhlY3V0ZVRha2VGaXJzdE9yVGhyb3coKVxuICAgICAgICAgICAgICAgIDogYXdhaXQgcXVlcnkuZXhlY3V0ZVRha2VGaXJzdE9yVGhyb3coKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGRiXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0RnJvbShcIlNlc3Npb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLndoZXJlKFwiU2Vzc2lvbi5zZXNzaW9uVG9rZW5cIiwgXCI9XCIsIHNlc3Npb25EYXRhLnNlc3Npb25Ub2tlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5leGVjdXRlVGFrZUZpcnN0T3JUaHJvdygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20ocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZGVsZXRlU2Vzc2lvbihzZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgICAgIGF3YWl0IGRiXG4gICAgICAgICAgICAgICAgLmRlbGV0ZUZyb20oXCJTZXNzaW9uXCIpXG4gICAgICAgICAgICAgICAgLndoZXJlKFwiU2Vzc2lvbi5zZXNzaW9uVG9rZW5cIiwgXCI9XCIsIHNlc3Npb25Ub2tlbilcbiAgICAgICAgICAgICAgICAuZXhlY3V0ZVRha2VGaXJzdE9yVGhyb3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgY3JlYXRlVmVyaWZpY2F0aW9uVG9rZW4oZGF0YSkge1xuICAgICAgICAgICAgYXdhaXQgZGIuaW5zZXJ0SW50byhcIlZlcmlmaWNhdGlvblRva2VuXCIpLnZhbHVlcyh0byhkYXRhKSkuZXhlY3V0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHVzZVZlcmlmaWNhdGlvblRva2VuKHsgaWRlbnRpZmllciwgdG9rZW4gfSkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBkYlxuICAgICAgICAgICAgICAgIC5kZWxldGVGcm9tKFwiVmVyaWZpY2F0aW9uVG9rZW5cIilcbiAgICAgICAgICAgICAgICAud2hlcmUoXCJWZXJpZmljYXRpb25Ub2tlbi50b2tlblwiLCBcIj1cIiwgdG9rZW4pXG4gICAgICAgICAgICAgICAgLndoZXJlKFwiVmVyaWZpY2F0aW9uVG9rZW4uaWRlbnRpZmllclwiLCBcIj1cIiwgaWRlbnRpZmllcik7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBwb3J0c1JldHVybmluZ1xuICAgICAgICAgICAgICAgID8gYXdhaXQgcXVlcnkucmV0dXJuaW5nQWxsKCkuZXhlY3V0ZVRha2VGaXJzdCgpXG4gICAgICAgICAgICAgICAgOiBhd2FpdCBkYlxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0RnJvbShcIlZlcmlmaWNhdGlvblRva2VuXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoKVxuICAgICAgICAgICAgICAgICAgICAud2hlcmUoXCJ0b2tlblwiLCBcIj1cIiwgdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIC5leGVjdXRlVGFrZUZpcnN0KClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBxdWVyeS5leGVjdXRlVGFrZUZpcnN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmcm9tKHJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogV3JhcHBlciBvdmVyIHRoZSBvcmlnaW5hbCBgS3lzZWx5YCBjbGFzcyBpbiBvcmRlciB0byB2YWxpZGF0ZSB0aGUgcGFzc2VkIGluXG4gKiBkYXRhYmFzZSBpbnRlcmZhY2UuIEEgcmVndWxhciBLeXNlbHkgaW5zdGFuY2UgbWF5IGFsc28gYmUgdXNlZCwgYnV0IHdyYXBwaW5nXG4gKiBpdCBlbnN1cmVzIHRoZSBkYXRhYmFzZSBpbnRlcmZhY2UgaW1wbGVtZW50cyB0aGUgZmllbGRzIHRoYXQgQXV0aC5qc1xuICogcmVxdWlyZXMuIFdoZW4gdXNlZCB3aXRoIGBreXNlbHktY29kZWdlbmAsIHRoZSBgQ29kZWdlbmAgdHlwZSBjYW4gYmUgcGFzc2VkIGFzXG4gKiB0aGUgc2Vjb25kIGdlbmVyaWMgYXJndW1lbnQuIFRoZSBnZW5lcmF0ZWQgdHlwZXMgd2lsbCBiZSB1c2VkLCBhbmRcbiAqIGBLeXNlbHlBdXRoYCB3aWxsIG9ubHkgdmVyaWZ5IHRoYXQgdGhlIGNvcnJlY3QgZmllbGRzIGV4aXN0LlxuICovXG5leHBvcnQgY2xhc3MgS3lzZWx5QXV0aCBleHRlbmRzIEt5c2VseSB7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@auth/kysely-adapter/index.js\n");

/***/ })

};
;